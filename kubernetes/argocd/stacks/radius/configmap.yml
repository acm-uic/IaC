---
apiVersion: v1
kind: ConfigMap
metadata:
  name: radius-config
  namespace: radius
data:
  raddb-sites-enabled-default: |
    ######################################################################
    #
    #  As of 2.0.0, FreeRADIUS supports virtual hosts using the
    #  "server" section, and configuration directives.
    #
    #  Virtual hosts should be put into the "sites-available"
    #  directory.  Soft links should be created in the "sites-enabled"
    #  directory to these files.  This is done in a normal installation.
    #
    #  If you are using 802.1X (EAP) authentication, please see also
    #  the "inner-tunnel" virtual server.  You will likely have to edit
    #  that, too, for authentication to work.
    #
    #  $Id: c60c0ba4c8728fac10b190dbb3b752f9df317c07 $
    #
    ######################################################################
    #
    #  Read "man radiusd" before editing this file.  See the section
    #  titled DEBUGGING.  It outlines a method where you can quickly
    #  obtain the configuration you want, without running into
    #  trouble.  See also "man unlang", which documents the format
    #  of this file.
    #
    #  This configuration is designed to work in the widest possible
    #  set of circumstances, with the widest possible number of
    #  authentication methods.  This means that in general, you should
    #  need to make very few changes to this file.
    #
    #  The best way to configure the server for your local system
    #  is to CAREFULLY edit this file.  Most attempts to make large
    #  edits to this file will BREAK THE SERVER.  Any edits should
    #  be small, and tested by running the server with "radiusd -X".
    #  Once the edits have been verified to work, save a copy of these
    #  configuration files somewhere.  (e.g. as a "tar" file).  Then,
    #  make more edits, and test, as above.
    #
    #  There are many "commented out" references to modules such
    #  as ldap, sql, etc.  These references serve as place-holders.
    #  If you need the functionality of that module, then configure
    #  it in radiusd.conf, and un-comment the references to it in
    #  this file.  In most cases, those small changes will result
    #  in the server being able to connect to the DB, and to
    #  authenticate users.
    #
    ######################################################################

    server default {
    #
    #  If you want the server to listen on additional addresses, or on
    #  additional ports, you can use multiple "listen" sections.
    #
    #  Each section make the server listen for only one type of packet,
    #  therefore authentication and accounting have to be configured in
    #  different sections.
    #
    #  The server ignore all "listen" section if you are using '-i' and '-p'
    #  on the command line.
    #
    listen {
      #  Type of packets to listen for.
      #  Allowed values are:
      #  auth  listen for authentication packets
      #  acct  listen for accounting packets
      #  proxy   IP to use for sending proxied packets
      #  detail  Read from the detail file.  For examples, see
      #               raddb/sites-available/copy-acct-to-home-server
      #  status  listen for Status-Server packets.  For examples,
      #    see raddb/sites-available/status
      #  coa     listen for CoA-Request and Disconnect-Request
      #    packets.  For examples, see the file
      #    raddb/sites-available/coa
      #
      type = auth

      #  Note: "type = proxy" lets you control the source IP used for
      #        proxying packets, with some limitations:
      #
      #    * A proxy listener CANNOT be used in a virtual server section.
      #    * You should probably set "port = 0".
      #    * Any "clients" configuration will be ignored.
      #
      #  See also proxy.conf, and the "src_ipaddr" configuration entry
      #  in the sample "home_server" section.  When you specify the
      #  source IP address for packets sent to a home server, the
      #  proxy listeners are automatically created.

      #  ipaddr/ipv4addr/ipv6addr - IP address on which to listen.
      #  If multiple ones are listed, only the first one will
      #  be used, and the others will be ignored.
      #
      #  The configuration options accept the following syntax:
      #
      #  ipv4addr - IPv4 address (e.g.192.0.2.3)
      #        - wildcard (i.e. *)
      #        - hostname (radius.example.com)
      #          Only the A record for the host name is used.
      #        If there is no A record, an error is returned,
      #        and the server fails to start.
      #
      #  ipv6addr - IPv6 address (e.g. 2001:db8::1)
      #        - wildcard (i.e. *)
      #        - hostname (radius.example.com)
      #          Only the AAAA record for the host name is used.
      #        If there is no AAAA record, an error is returned,
      #        and the server fails to start.
      #
      #  ipaddr   - IPv4 address as above
      #        - IPv6 address as above
      #        - wildcard (i.e. *), which means IPv4 wildcard.
      #      - hostname
      #        If there is only one A or AAAA record returned
      #        for the host name, it is used.
      #        If multiple A or AAAA records are returned
      #        for the host name, only the first one is used.
      #        If both A and AAAA records are returned
      #        for the host name, only the A record is used.
      #
      # ipv4addr = *
      # ipv6addr = *
      ipaddr = *

      #  Port on which to listen.
      #  Allowed values are:
      #  integer port number (1812)
      #  0 means "use /etc/services for the proper port"
      port = 0

      #  Some systems support binding to an interface, in addition
      #  to the IP address.  This feature isn't strictly necessary,
      #  but for sites with many IP addresses on one interface,
      #  it's useful to say "listen on all addresses for eth0".
      #
      #  If your system does not support this feature, you will
      #  get an error if you try to use it.
      #
    #  interface = eth0

      #  Per-socket lists of clients.  This is a very useful feature.
      #
      #  The name here is a reference to a section elsewhere in
      #  radiusd.conf, or clients.conf.  Having the name as
      #  a reference allows multiple sockets to use the same
      #  set of clients.
      #
      #  If this configuration is used, then the global list of clients
      #  is IGNORED for this "listen" section.  Take care configuring
      #  this feature, to ensure you don't accidentally disable a
      #  client you need.
      #
      #  See clients.conf for the configuration of "per_socket_clients".
      #
    #  clients = per_socket_clients

      #
      #  Set the default UDP receive buffer size.  In most cases,
      #  the default values set by the kernel are fine.  However, in
      #  some cases the NASes will send large packets, and many of
      #  them at a time.  It is then possible to overflow the
      #  buffer, causing the kernel to drop packets before they
      #  reach FreeRADIUS.  Increasing the size of the buffer will
      #  avoid these packet drops.
      #
    #  recv_buff = 65536

      #
      #  Connection limiting for sockets with "proto = tcp".
      #
      #  This section is ignored for other kinds of sockets.
      #
      limit {
            #
            #  Limit the number of simultaneous TCP connections to the socket
            #
            #  The default is 16.
            #  Setting this to 0 means "no limit"
            max_connections = 16

            #  The per-socket "max_requests" option does not exist.

            #
            #  The lifetime, in seconds, of a TCP connection.  After
            #  this lifetime, the connection will be closed.
            #
            #  Setting this to 0 means "forever".
            lifetime = 0

            #
            #  The idle timeout, in seconds, of a TCP connection.
            #  If no packets have been received over the connection for
            #  this time, the connection will be closed.
            #
            #  Setting this to 0 means "no timeout".
            #
            #  We STRONGLY RECOMMEND that you set an idle timeout.
            #
            idle_timeout = 30
      }
    }

    #
    #  This second "listen" section is for listening on the accounting
    #  port, too.
    #
    listen {
      ipaddr = *
    #  ipv6addr = ::
      port = 0
      type = acct
    #  interface = eth0
    #  clients = per_socket_clients

      limit {
        #  The number of packets received can be rate limited via the
        #  "max_pps" configuration item.  When it is set, the server
        #  tracks the total number of packets received in the previous
        #  second.  If the count is greater than "max_pps", then the
        #  new packet is silently discarded.  This helps the server
        #  deal with overload situations.
        #
        #  The packets/s counter is tracked in a sliding window.  This
        #  means that the pps calculation is done for the second
        #  before the current packet was received.  NOT for the current
        #  wall-clock second, and NOT for the previous wall-clock second.
        #
        #  Useful values are 0 (no limit), or 100 to 10000.
        #  Values lower than 100 will likely cause the server to ignore
        #  normal traffic.  Few systems are capable of handling more than
        #  10K packets/s.
        #
        #  It is most useful for accounting systems.  Set it to 50%
        #  more than the normal accounting load, and you can be sure that
        #  the server will never get overloaded
        #
    #    max_pps = 0

        # Only for "proto = tcp". These are ignored for "udp" sockets.
        #
    #    idle_timeout = 0
    #    lifetime = 0
    #    max_connections = 0
      }
    }

    # IPv6 versions of the above - read their full config to understand options
    listen {
      type = auth
      ipv6addr = ::  # any.  ::1 == localhost
      port = 0
    #  interface = eth0
    #  clients = per_socket_clients
      limit {
            max_connections = 16
            lifetime = 0
            idle_timeout = 30
      }
    }

    listen {
      ipv6addr = ::
      port = 0
      type = acct
    #  interface = eth0
    #  clients = per_socket_clients

      limit {
    #    max_pps = 0
    #    idle_timeout = 0
    #    lifetime = 0
    #    max_connections = 0
      }
    }

    #  Authorization. First preprocess (hints and huntgroups files),
    #  then realms, and finally look in the "users" file.
    #
    #  Any changes made here should also be made to the "inner-tunnel"
    #  virtual server.
    #
    #  The order of the realm modules will determine the order that
    #  we try to find a matching realm.
    #
    #  Make *sure* that 'preprocess' comes before any realm if you
    #  need to setup hints for the remote radius server
    authorize {
      #
      #  Take a User-Name, and perform some checks on it, for spaces and other
      #  invalid characters.  If the User-Name appears invalid, reject the
      #  request.
      #
      #  See policy.d/filter for the definition of the filter_username policy.
      #
      filter_username

      #
      #  Some broken equipment sends passwords with embedded zeros.
      #  i.e. the debug output will show
      #
      #  User-Password = "password\000\000"
      #
      #  This policy will fix it to just be "password".
      #
    #  filter_password

      #
      #  The preprocess module takes care of sanitizing some bizarre
      #  attributes in the request, and turning them into attributes
      #  which are more standard.
      #
      #  It takes care of processing the 'raddb/mods-config/preprocess/hints' 
      #  and the 'raddb/mods-config/preprocess/huntgroups' files.
      preprocess

      #  If you intend to use CUI and you require that the Operator-Name
      #  be set for CUI generation and you want to generate CUI also
      #  for your local clients then uncomment the operator-name
      #  below and set the operator-name for your clients in clients.conf
    #  operator-name

      #
      #  If you want to generate CUI for some clients that do not
      #  send proper CUI requests, then uncomment the
      #  cui below and set "add_cui = yes" for these clients in clients.conf
    #  cui

      #
      #  If you want to have a log of authentication requests,
      #  un-comment the following line.
    #  auth_log

      #
      #  The chap module will set 'Auth-Type := CHAP' if we are
      #  handling a CHAP request and Auth-Type has not already been set
      chap

      #
      #  If the users are logging in with an MS-CHAP-Challenge
      #  attribute for authentication, the mschap module will find
      #  the MS-CHAP-Challenge attribute, and add 'Auth-Type := MS-CHAP'
      #  to the request, which will cause the server to then use
      #  the mschap module for authentication.
      mschap

      #
      #  If you have a Cisco SIP server authenticating against
      #  FreeRADIUS, uncomment the following line, and the 'digest'
      #  line in the 'authenticate' section.
      digest

      #
      #  The WiMAX specification says that the Calling-Station-Id
      #  is 6 octets of the MAC.  This definition conflicts with
      #  RFC 3580, and all common RADIUS practices.  Un-commenting
      #  the "wimax" module here means that it will fix the
      #  Calling-Station-Id attribute to the normal format as
      #  specified in RFC 3580 Section 3.21
    #  wimax

      #
      #  Look for IPASS style 'realm/', and if not found, look for
      #  '@realm', and decide whether or not to proxy, based on
      #  that.
    #  IPASS

      #
      # Look for realms in user@domain format
      suffix
    #  ntdomain

      #
      #  This module takes care of EAP-MD5, EAP-TLS, and EAP-LEAP
      #  authentication.
      #
      #  It also sets the EAP-Type attribute in the request
      #  attribute list to the EAP type from the packet.
      #
      #  The EAP module returns "ok" or "updated" if it is not yet ready
      #  to authenticate the user.  The configuration below checks for
      #  "ok", and stops processing the "authorize" section if so.
      #
      #  Any LDAP and/or SQL servers will not be queried for the
      #  initial set of packets that go back and forth to set up
      #  TTLS or PEAP.
      #
      #  The "updated" check is commented out for compatibility with
      #  previous versions of this configuration, but you may wish to
      #  uncomment it as well; this will further reduce the number of
      #  LDAP and/or SQL queries for TTLS or PEAP.
      #
      eap {
        ok = return
    #    updated = return
      }

      #
      #  Pull crypt'd passwords from /etc/passwd or /etc/shadow,
      #  using the system API's to get the password.  If you want
      #  to read /etc/passwd or /etc/shadow directly, see the
      #  mods-available/passwd module.
      #
    #  unix

      #
      #  Read the 'users' file.  In v3, this is located in
      #  raddb/mods-config/files/authorize
      files

      #
      #  Look in an SQL database.  The schema of the database
      #  is meant to mirror the "users" file.
      #
      #  See "Authorization Queries" in mods-available/sql
      -sql

      #
      #  If you are using /etc/smbpasswd, and are also doing
      #  mschap authentication, the un-comment this line, and
      #  configure the 'smbpasswd' module.
    #  smbpasswd

      #
      #  The ldap module reads passwords from the LDAP database.
      -ldap
      if ((ok || updated) && User-Password && !control:Auth-Type) {
          update {
              control:Auth-Type := ldap
          }
      }

      #
      #  Enforce daily limits on time spent logged in.
    #  daily

      #
      expiration
      logintime

      #
      #  If no other module has claimed responsibility for
      #  authentication, then try to use PAP.  This allows the
      #  other modules listed above to add a "known good" password
      #  to the request, and to do nothing else.  The PAP module
      #  will then see that password, and use it to do PAP
      #  authentication.
      #
      #  This module should be listed last, so that the other modules
      #  get a chance to set Auth-Type for themselves.
      #
      pap

      #
      #  If "status_server = yes", then Status-Server messages are passed
      #  through the following section, and ONLY the following section.
      #  This permits you to do DB queries, for example.  If the modules
      #  listed here return "fail", then NO response is sent.
      #
    #  Autz-Type Status-Server {
    #
    #  }
    }


    #  Authentication.
    #
    #
    #  This section lists which modules are available for authentication.
    #  Note that it does NOT mean 'try each module in order'.  It means
    #  that a module from the 'authorize' section adds a configuration
    #  attribute 'Auth-Type := FOO'.  That authentication type is then
    #  used to pick the appropriate module from the list below.
    #

    #  In general, you SHOULD NOT set the Auth-Type attribute.  The server
    #  will figure it out on its own, and will do the right thing.  The
    #  most common side effect of erroneously setting the Auth-Type
    #  attribute is that one authentication method will work, but the
    #  others will not.
    #
    #  The common reasons to set the Auth-Type attribute by hand
    #  is to either forcibly reject the user (Auth-Type := Reject),
    #  or to or forcibly accept the user (Auth-Type := Accept).
    #
    #  Note that Auth-Type := Accept will NOT work with EAP.
    #
    #  Please do not put "unlang" configurations into the "authenticate"
    #  section.  Put them in the "post-auth" section instead.  That's what
    #  the post-auth section is for.
    #
    authenticate {
      #
      #  PAP authentication, when a back-end database listed
      #  in the 'authorize' section supplies a password.  The
      #  password can be clear-text, or encrypted.
      Auth-Type PAP {
        pap
      }

      #
      #  Most people want CHAP authentication
      #  A back-end database listed in the 'authorize' section
      #  MUST supply a CLEAR TEXT password.  Encrypted passwords
      #  won't work.
      Auth-Type CHAP {
        chap
      }

      #
      #  MSCHAP authentication.
      Auth-Type MS-CHAP {
        mschap
      }

      #
      #  For old names, too.
      #
      mschap

      #
      #  If you have a Cisco SIP server authenticating against
      #  FreeRADIUS, uncomment the following line, and the 'digest'
      #  line in the 'authorize' section.
      digest

      #
      #  Pluggable Authentication Modules.
    #  pam

      #  Uncomment it if you want to use ldap for authentication
      #
      #  Note that this means "check plain-text password against
      #  the ldap database", which means that EAP won't work,
      #  as it does not supply a plain-text password.
      #
      #  We do NOT recommend using this.  LDAP servers are databases.
      #  They are NOT authentication servers.  FreeRADIUS is an
      #  authentication server, and knows what to do with authentication.
      #  LDAP servers do not.
      #
      Auth-Type LDAP {
        ldap
      }

      #
      #  Allow EAP authentication.
      eap

      #
      #  The older configurations sent a number of attributes in
      #  Access-Challenge packets, which wasn't strictly correct.
      #  If you want to filter out these attributes, uncomment
      #  the following lines.
      #
    #  Auth-Type eap {
    #    eap {
    #      handled = 1
    #    }
    #    if (handled && (Response-Packet-Type == Access-Challenge)) {
    #      attr_filter.access_challenge.post-auth
    #      handled  # override the "updated" code from attr_filter
    #    }
    #  }
    }


    #
    #  Pre-accounting.  Decide which accounting type to use.
    #
    preacct {
      preprocess

      #
      #  Merge Acct-[Input|Output]-Gigawords and Acct-[Input-Output]-Octets
      #  into a single 64bit counter Acct-[Input|Output]-Octets64.
      #
    #  acct_counters64

      #
      #  Session start times are *implied* in RADIUS.
      #  The NAS never sends a "start time".  Instead, it sends
      #  a start packet, *possibly* with an Acct-Delay-Time.
      #  The server is supposed to conclude that the start time
      #  was "Acct-Delay-Time" seconds in the past.
      #
      #  The code below creates an explicit start time, which can
      #  then be used in other modules.  It will be *mostly* correct.
      #  Any errors are due to the 1-second resolution of RADIUS,
      #  and the possibility that the time on the NAS may be off.
      #
      #  The start time is: NOW - delay - session_length
      #

    #  update request {
    #      &FreeRADIUS-Acct-Session-Start-Time = "%{expr: %l - %{%{Acct-Session-Time}:-0} - %{%{Acct-Delay-Time}:-0}}"
    #  }


      #
      #  Ensure that we have a semi-unique identifier for every
      #  request, and many NAS boxes are broken.
      acct_unique

      #
      #  Look for IPASS-style 'realm/', and if not found, look for
      #  '@realm', and decide whether or not to proxy, based on
      #  that.
      #
      #  Accounting requests are generally proxied to the same
      #  home server as authentication requests.
    #  IPASS
      suffix
    #  ntdomain

      #
      #  Read the 'acct_users' file
      files
    }

    #
    #  Accounting.  Log the accounting data.
    #
    accounting {
      #  Update accounting packet by adding the CUI attribute
      #  recorded from the corresponding Access-Accept
      #  use it only if your NAS boxes do not support CUI themselves
    #  cui
      #
      #  Create a 'detail'ed log of the packets.
      #  Note that accounting requests which are proxied
      #  are also logged in the detail file.
      detail
    #  daily

      #  Update the wtmp file
      #
      #  If you don't use "radlast", you can delete this line.
      unix

      #
      #  For Simultaneous-Use tracking.
      #
      #  Due to packet losses in the network, the data here
      #  may be incorrect.  There is little we can do about it.
    #  radutmp
    #  sradutmp

      #  Return an address to the IP Pool when we see a stop record.
    #  sqlippool

      #
      #  Log traffic to an SQL database.
      #
      #  See "Accounting queries" in mods-available/sql
      -sql

      #
      #  If you receive stop packets with zero session length,
      #  they will NOT be logged in the database.  The SQL module
      #  will print a message (only in debugging mode), and will
      #  return "noop".
      #
      #  You can ignore these packets by uncommenting the following
      #  three lines.  Otherwise, the server will not respond to the
      #  accounting request, and the NAS will retransmit.
      #
    #  if (noop) {
    #    ok
    #  }

      #  Cisco VoIP specific bulk accounting
    #  pgsql-voip

      # For Exec-Program and Exec-Program-Wait
      exec

      #  Filter attributes from the accounting response.
      attr_filter.accounting_response

      #
      #  See "Autz-Type Status-Server" for how this works.
      #
    #  Acct-Type Status-Server {
    #
    #  }
    }


    #  Session database, used for checking Simultaneous-Use. Either the radutmp
    #  or rlm_sql module can handle this.
    #  The rlm_sql module is *much* faster
    session {
    #  radutmp

      #
      #  See "Simultaneous Use Checking Queries" in mods-available/sql
    #  sql
    }


    #  Post-Authentication
    #  Once we KNOW that the user has been authenticated, there are
    #  additional steps we can take.
    post-auth {
      #
      #  If you need to have a State attribute, you can
      #  add it here.  e.g. for later CoA-Request with
      #  State, and Service-Type = Authorize-Only.
      #
    #  if (!&reply:State) {
    #    update reply {
    #      State := "0x%{randstr:16h}"
    #    }
    #  }

      #
      #  For EAP-TTLS and PEAP, add the cached attributes to the reply.
      #  The "session-state" attributes are automatically cached when
      #  an Access-Challenge is sent, and automatically retrieved
      #  when an Access-Request is received.
      #
      #  The session-state attributes are automatically deleted after
      #  an Access-Reject or Access-Accept is sent.
      #
      #  If both session-state and reply contain a User-Name attribute, remove
      #  the one in the reply if it is just a copy of the one in the request, so
      #  we don't end up with two User-Name attributes.

      if (session-state:User-Name && reply:User-Name && request:User-Name && (reply:User-Name == request:User-Name)) {
        update reply {
          &User-Name !* ANY
        }
      }
      update {
        &reply: += &session-state:
      }

      #  Refresh leases when we see a start or alive. Return an address to
      #  the IP Pool when we see a stop record.
    #  sqlippool


      #  Create the CUI value and add the attribute to Access-Accept.
      #  Uncomment the line below if *returning* the CUI.
    #  cui

      #  Create empty accounting session to make simultaneous check
      #  more robust. See the accounting queries configuration in
      #  raddb/mods-config/sql/main/*/queries.conf for details.
      #
      #  The "sql_session_start" policy is defined in
      #  raddb/policy.d/accounting.  See that file for more details.
    #  sql_session_start

      #
      #  If you want to have a log of authentication replies,
      #  un-comment the following line, and enable the
      #  'detail reply_log' module.
    #  reply_log

      #
      #  After authenticating the user, do another SQL query.
      #
      #  See "Authentication Logging Queries" in mods-available/sql
      -sql

      #
      #  Un-comment the following if you want to modify the user's object
      #  in LDAP after a successful login.
      #
    #  ldap

      # For Exec-Program and Exec-Program-Wait
      exec

      #
      #  Calculate the various WiMAX keys.  In order for this to work,
      #  you will need to define the WiMAX NAI, usually via
      #
      #  update request {
      #         &WiMAX-MN-NAI = "%{User-Name}"
      #  }
      #
      #  If you want various keys to be calculated, you will need to
      #  update the reply with "template" values.  The module will see
      #  this, and replace the template values with the correct ones
      #  taken from the cryptographic calculations.  e.g.
      #
      #   update reply {
      #    &WiMAX-FA-RK-Key = 0x00
      #    &WiMAX-MSK = "%{reply:EAP-MSK}"
      #  }
      #
      #  You may want to delete the MS-MPPE-*-Keys from the reply,
      #  as some WiMAX clients behave badly when those attributes
      #  are included.  See "raddb/modules/wimax", configuration
      #  entry "delete_mppe_keys" for more information.
      #
    #  wimax


      #  If there is a client certificate (EAP-TLS, sometimes PEAP
      #  and TTLS), then some attributes are filled out after the
      #  certificate verification has been performed.  These fields
      #  MAY be available during the authentication, or they may be
      #  available only in the "post-auth" section.
      #
      #  The first set of attributes contains information about the
      #  issuing certificate which is being used.  The second
      #  contains information about the client certificate (if
      #  available).
    #
    #  update reply {
    #         Reply-Message += "%{TLS-Cert-Serial}"
    #         Reply-Message += "%{TLS-Cert-Expiration}"
    #         Reply-Message += "%{TLS-Cert-Subject}"
    #         Reply-Message += "%{TLS-Cert-Issuer}"
    #         Reply-Message += "%{TLS-Cert-Common-Name}"
    #         Reply-Message += "%{TLS-Cert-Subject-Alt-Name-Email}"
    #
    #         Reply-Message += "%{TLS-Client-Cert-Serial}"
    #         Reply-Message += "%{TLS-Client-Cert-Expiration}"
    #         Reply-Message += "%{TLS-Client-Cert-Subject}"
    #         Reply-Message += "%{TLS-Client-Cert-Issuer}"
    #         Reply-Message += "%{TLS-Client-Cert-Common-Name}"
    #         Reply-Message += "%{TLS-Client-Cert-Subject-Alt-Name-Email}"
    #  }

      #  Insert class attribute (with unique value) into response,
      #  aids matching auth and acct records, and protects against duplicate
      #  Acct-Session-Id. Note: Only works if the NAS has implemented
      #  RFC 2865 behaviour for the class attribute, AND if the NAS
      #  supports long Class attributes.  Many older or cheap NASes
      #  only support 16-octet Class attributes.
    #  insert_acct_class

      #  MacSEC requires the use of EAP-Key-Name.  However, we don't
      #  want to send it for all EAP sessions.  Therefore, the EAP
      #  modules put required data into the EAP-Session-Id attribute.
      #  This attribute is never put into a request or reply packet.
      #
      #  Uncomment the next few lines to copy the required data into
      #  the EAP-Key-Name attribute
    #  if (&reply:EAP-Session-Id) {
    #    update reply {
    #      EAP-Key-Name := &reply:EAP-Session-Id
    #    }
    #  }

      #  Remove reply message if the response contains an EAP-Message
      remove_reply_message_if_eap

      #
      #  Access-Reject packets are sent through the REJECT sub-section of the
      #  post-auth section.
      #
      #  Add the ldap module name (or instance) if you have set
      #  'edir = yes' in the ldap module configuration
      #
      #  The "session-state" attributes are not available here.
      #
      Post-Auth-Type REJECT {
        # log failed authentications in SQL, too.
        -sql
        attr_filter.access_reject

        # Insert EAP-Failure message if the request was
        # rejected by policy instead of because of an
        # authentication failure
        eap

        #  Remove reply message if the response contains an EAP-Message
        remove_reply_message_if_eap
      }

      #
      #  Filter access challenges.
      #
      Post-Auth-Type Challenge {
    #    remove_reply_message_if_eap
    #    attr_filter.access_challenge.post-auth
      }

    }

    #
    #  When the server decides to proxy a request to a home server,
    #  the proxied request is first passed through the pre-proxy
    #  stage.  This stage can re-write the request, or decide to
    #  cancel the proxy.
    #
    #  Only a few modules currently have this method.
    #
    pre-proxy {
      # Before proxing the request add an Operator-Name attribute identifying
      # if the operator-name is found for this client.
      # No need to uncomment this if you have already enabled this in
      # the authorize section.
    #  operator-name

      #  The client requests the CUI by sending a CUI attribute
      #  containing one zero byte.
      #  Uncomment the line below if *requesting* the CUI.
    #  cui

      #  Uncomment the following line if you want to change attributes
      #  as defined in the preproxy_users file.
    #  files

      #  Uncomment the following line if you want to filter requests
      #  sent to remote servers based on the rules defined in the
      #  'attrs.pre-proxy' file.
    #  attr_filter.pre-proxy

      #  If you want to have a log of packets proxied to a home
      #  server, un-comment the following line, and the
      #  'detail pre_proxy_log' section, above.
    #  pre_proxy_log
    }

    #
    #  When the server receives a reply to a request it proxied
    #  to a home server, the request may be massaged here, in the
    #  post-proxy stage.
    #
    post-proxy {

      #  If you want to have a log of replies from a home server,
      #  un-comment the following line, and the 'detail post_proxy_log'
      #  section, above.
    #  post_proxy_log

      #  Uncomment the following line if you want to filter replies from
      #  remote proxies based on the rules defined in the 'attrs' file.
    #  attr_filter.post-proxy

      #
      #  If you are proxying LEAP, you MUST configure the EAP
      #  module, and you MUST list it here, in the post-proxy
      #  stage.
      #
      #  You MUST also use the 'nostrip' option in the 'realm'
      #  configuration.  Otherwise, the User-Name attribute
      #  in the proxied request will not match the user name
      #  hidden inside of the EAP packet, and the end server will
      #  reject the EAP request.
      #
      eap

      #
      #  If the server tries to proxy a request and fails, then the
      #  request is processed through the modules in this section.
      #
      #  The main use of this section is to permit robust proxying
      #  of accounting packets.  The server can be configured to
      #  proxy accounting packets as part of normal processing.
      #  Then, if the home server goes down, accounting packets can
      #  be logged to a local "detail" file, for processing with
      #  radrelay.  When the home server comes back up, radrelay
      #  will read the detail file, and send the packets to the
      #  home server.
      #
      #  See the "mods-available/detail.example.com" file for more
      #  details on writing a detail file specifically for one
      #  destination.
      #
      #  See the "sites-available/robust-proxy-accounting" virtual
      #  server for more details on reading this "detail" file.
      #
      #  With this configuration, the server always responds to
      #  Accounting-Requests from the NAS, but only writes
      #  accounting packets to disk if the home server is down.
      #
    #  Post-Proxy-Type Fail-Accounting {
    #      detail.example.com
    #  }
    }
    }

  raddb-mods-enabled-ldap: |
    # -*- text -*-
    #
    #  $Id: 1741d7e6ed472617f190f90a545272be980a6ff1 $

    #
    #  Lightweight Directory Access Protocol (LDAP)
    #
    ldap {
      #  Note that this needs to match the name(s) in the LDAP server
      #  certificate, if you're using ldaps.  See OpenLDAP documentation
      #  for the behavioral semantics of specifying more than one host.
      #
      #  Depending on the libldap in use, server may be an LDAP URI.
      #  In the case of OpenLDAP this allows additional the following
      #  additional schemes:
      #  - ldaps:// (LDAP over SSL)
      #  - ldapi:// (LDAP over Unix socket)
      #  - ldapc:// (Connectionless LDAP)
      server = "activedirectory.acmuic.org"
    #  server = 'ldap.rrdns.example.org'
    #  server = 'ldap.rrdns.example.org'

      #  Port to connect on, defaults to 389, will be ignored for LDAP URIs.
    #  port = 389
      port = "389"

      #  Administrator account for searching and possibly modifying.
      #  If using SASL + KRB5 these should be commented out.
    #  identity = 'cn=admin,dc=example,dc=org'
    #  password = mypass
      identity = "VAULT_REPLACE_LDAP_IDENTITY_REPLACE_VAULT"
      password = "VAULT_REPLACE_LDAP_PASSWORD_REPLACE_VAULT"

      #  Unless overridden in another section, the dn from which all
      #  searches will start from.
      base_dn = "OU=ACMUsers,DC=acmuic,DC=org"

      #
      #  You can run the 'ldapsearch' command line tool using the
      #  parameters from this module's configuration.
      #
      #    ldapsearch -D ${identity} -w ${password} -h ${server}  -b 'CN=user,${base_dn}'
      #
      #  That will give you the LDAP information for 'user'.
      #
      #  Group membership can be queried by using the above "ldapsearch" string,
      #  and adding "memberof" qualifiers.  For ActiveDirectory, use:
      #
      #    ldapsearch ... '(&(objectClass=user)(sAMAccountName=user)(memberof=CN=group,${base_dn}))'
      #
      #  Where 'user' is the user as above, and 'group' is the group you are querying for.
      #

      #
      #  SASL parameters to use for admin binds
      #
      #  When we're prompted by the SASL library, these control
      #  the responses given, as well as the identity and password
      #  directives above.
      #
      #  If any directive is commented out, a NULL response will be
      #  provided to cyrus-sasl.
      #
      #  Unfortunately the only way to control Keberos here is through
      #  environmental variables, as cyrus-sasl provides no API to
      #  set the krb5 config directly.
      #
      #  Full documentation for MIT krb5 can be found here:
      #
      #  http://web.mit.edu/kerberos/krb5-devel/doc/admin/env_variables.html
      #
      #  At a minimum you probably want to set KRB5_CLIENT_KTNAME.
      #
      sasl {
        # SASL mechanism
    #    mech = 'PLAIN'

        # SASL authorisation identity to proxy.
    #    proxy = 'autz_id'

        # SASL realm. Used for kerberos.
    #    realm = 'example.org'
      }

      #
      #  Generic valuepair attribute
      #

      #  If set, this will attribute will be retrieved in addition to any
      #  mapped attributes.
      #
      #  Values should be in the format:
      #    <radius attr> <op> <value>
      #
      #  Where:
      #    <radius attr>:  Is the attribute you wish to create
      #       with any valid list and request qualifiers.
      #    <op>:     Is any assignment operator (=, :=, +=, -=).
      #    <value>:  Is the value to parse into the new valuepair.
      #       If the value is wrapped in double quotes it
      #      will be xlat expanded.
    #  valuepair_attribute = 'radiusAttribute'

      #
      #  Mapping of LDAP directory attributes to RADIUS dictionary attributes.
      #

      #  WARNING: Although this format is almost identical to the unlang
      #  update section format, it does *NOT* mean that you can use other
      #  unlang constructs in module configuration files.
      #
      #  Configuration items are in the format:
      #   <radius attr> <op> <ldap attr>
      #
      #  Where:
      #    <radius attr>:  Is the destination RADIUS attribute
      #       with any valid list and request qualifiers.
      #    <op>:     Is any assignment attribute (=, :=, +=, -=).
      #    <ldap attr>:  Is the attribute associated with user or
      #      profile objects in the LDAP directory.
      #       If the attribute name is wrapped in double
      #       quotes it will be xlat expanded.
      #
      #  Request and list qualifiers may also be placed after the 'update'
      #  section name to set defaults destination requests/lists
      #  for unqualified RADIUS attributes.
      #
      #  Note: LDAP attribute names should be single quoted unless you want
      #  the name value to be derived from an xlat expansion, or an
      #  attribute ref.
      update {
        control:Password-With-Header  += 'userPassword'
    #    control:NT-Password    := 'ntPassword'
    #    reply:Reply-Message    := 'radiusReplyMessage'
    #    reply:Tunnel-Type    := 'radiusTunnelType'
    #    reply:Tunnel-Medium-Type  := 'radiusTunnelMediumType'
    #    reply:Tunnel-Private-Group-ID  := 'radiusTunnelPrivategroupId'

        #  Where only a list is specified as the RADIUS attribute,
        #  the value of the LDAP attribute is parsed as a valuepair
        #  in the same format as the 'valuepair_attribute' (above).
        control:      += 'radiusControlAttribute'
        request:      += 'radiusRequestAttribute'
        reply:        += 'radiusReplyAttribute'
      }

      #  Set to yes if you have eDirectory and want to use the universal
      #  password mechanism.
    #  edir = no

      #  Set to yes if you want to bind as the user after retrieving the
      #  Cleartext-Password. This will consume the login grace, and
      #  verify user authorization.
    #  edir_autz = no

      #  Note: set_auth_type was removed in v3.x.x
      #
      #  Equivalent functionality can be achieved by adding the
      #  following "if" statement to the authorize {} section of
      #  the virtual server, after the "ldap" module.  For example:
      #
      #    ...
      #    ldap
      #    if ((ok || updated) && User-Password && !control:Auth-Type) {
      #        update {
      #            control:Auth-Type := ldap
      #        }
      #    }
      #    ...
      #
      #  You will also need to uncomment the "Auth-Type LDAP" block in the
      #  "authenticate" section.
      #

      #
      #  Name of the attribute that contains the user DN.
      #  The default name is LDAP-UserDn.
      #
      #  If you have multiple LDAP instances, you should
      #  change this configuration item to:
      #
      #  ${.:instance}-LDAP-UserDn
      #
      #  That change allows the modules to set their own
      #  User DN, and to not conflict with each other.
      #
      user_dn = "LDAP-UserDn"

      #
      #  User object identification.
      #
      user {
        #  Where to start searching in the tree for users
        base_dn = "${..base_dn}"

        #  Filter for user objects, should be specific enough
        #  to identify a single user object.
        #
        #  For Active Directory, you should use
        #  "samaccountname=" instead of "uid="
        #
        filter = "(samaccountname=%{%{Stripped-User-Name}:-%{User-Name}})"

        #  SASL parameters to use for user binds
        #
        #  When we're prompted by the SASL library, these control
        #  the responses given.
        #
        #  Any of the config items below may be an attribute ref
        #  or and expansion, so different SASL mechs, proxy IDs
        #  and realms may be used for different users.
        sasl {
          # SASL mechanism
    #      mech = 'PLAIN'

          # SASL authorisation identity to proxy.
    #      proxy = &User-Name

          # SASL realm. Used for kerberos.
    #      realm = 'example.org'
        }

        #  Search scope, may be 'base', 'one', sub' or 'children'
    #    scope = 'sub'

        #  Server side result sorting
        #
        #  A list of space delimited attributes to order the result
        #  set by, if the filter matches multiple objects.
        #  Only the first result in the set will be processed.
        #
        #  If the attribute name is prefixed with a hyphen '-' the
        #  sorting order will be reversed for that attribute.
        #
        #  If sort_by is set, and the server does not support sorting
        #  the search will fail.
    #    sort_by = '-uid'

        #  If this is undefined, anyone is authorised.
        #  If it is defined, the contents of this attribute
        #  determine whether or not the user is authorised
    #    access_attribute = 'dialupAccess'

        #  Control whether the presence of 'access_attribute'
        #  allows access, or denys access.
        #
        #  If 'yes', and the access_attribute is present, or
        #  'no' and the access_attribute is absent then access
        #  will be allowed.
        #
        #  If 'yes', and the access_attribute is absent, or
        #  'no' and the access_attribute is present, then
        #  access will not be allowed.
        #
        #  If the value of the access_attribute is 'false', it
        #  will negate the result.
        #
        #  e.g.
        #    access_positive = yes
        #    access_attribute = userAccessAllowed
        #
        #  With an LDAP object containing:
        #    userAccessAllowed: false
        #
        #  Will result in the user being locked out.
    #    access_positive = yes
      }

      #
      #  User membership checking.
      #
      group {
        #  Where to start searching in the tree for groups
        base_dn = "${..base_dn}"

        #  Filter for group objects, should match all available
        #  group objects a user might be a member of.
        #
        #  If using Active Directory you are likely to need "group"
        #  instead of "posixGroup".
        filter = '(objectClass=group)'

        # Search scope, may be 'base', 'one', sub' or 'children'
    #    scope = 'sub'

        #  Attribute that uniquely identifies a group.
        #  Is used when converting group DNs to group
        #  names.
    #    name_attribute = cn

        #  Filter to find all group objects a user is a member of.
        #  That is, group objects with attributes that
        #  identify members (the inverse of membership_attribute).
        #
        #  Note that this configuration references the "user_dn"
        #  configuration defined above.
        #
    #    membership_filter = "(|(member=%{control:${..user_dn}})(memberUid=%{%{Stripped-User-Name}:-%{User-Name}}))"

        #  The attribute, in user objects, which contain the names
        #  or DNs of groups a user is a member of.
        #
        #  Unless a conversion between group name and group DN is
        #  needed, there's no requirement for the group objects
        #  referenced to actually exist.
        #
        #  If the LDAP server does not support the "memberOf"
        #  attribute (or equivalent), then you will need to use the
        #  membership_filter option above instead. If you can't see
        #  the memberOf attribute then it is also possible that the
        #  LDAP bind user does not have the correct permissions to
        #  view it.
        membership_attribute = 'memberOf'

        #  If cacheable_name or cacheable_dn are enabled,
        #  all group information for the user will be
        #  retrieved from the directory and written to LDAP-Group
        #  attributes appropriate for the instance of rlm_ldap.
        #
        #  For group comparisons these attributes will be checked
        #  instead of querying the LDAP directory directly.
        #
        #  This feature is intended to be used with rlm_cache.
        #
        #  If you wish to use this feature, you should enable
        #  the type that matches the format of your check items
        #  i.e. if your groups are specified as DNs then enable
        #  cacheable_dn else enable cacheable_name.
    #    cacheable_name = 'no'
    #    cacheable_dn = 'no'

        #  Override the normal cache attribute (<inst>-LDAP-Group or
        #  LDAP-Group if using the default instance) and create a
        #  custom attribute.  This can help if multiple module instances
        #  are used in fail-over.
    #    cache_attribute = 'LDAP-Cached-Membership'

        #  If the group being checked is specified as a name, but
        #  the user's groups are referenced by DN, and one of those
        #  group DNs is invalid, the whole group check is treated as
        #  invalid, and a negative result will be returned.
        #  When set to 'yes', this option ignores invalid DN
        #  references.
    #    allow_dangling_group_ref = 'no'
      }

      #
      #  User profiles. RADIUS profile objects contain sets of attributes
      #  to insert into the request. These attributes are mapped using
      #  the same mapping scheme applied to user objects (the update section above).
      #
      profile {
        #  Filter for RADIUS profile objects
    #    filter = '(objectclass=radiusprofile)'

        #  The default profile.  This may be a DN or an attribute
        #  reference.
        #  To get old v2.2.x style behaviour, or to use the
        #  &User-Profile attribute to specify the default profile,
        #  set this to &control:User-Profile.
    #    default = 'cn=radprofile,dc=example,dc=org'

        #  The LDAP attribute containing profile DNs to apply
        #  in addition to the default profile above.  These are
        #  retrieved from the user object, at the same time as the
        #  attributes from the update section, are are applied
        #  if authorization is successful.
    #    attribute = 'radiusProfileDn'
      }

      #
      #  Bulk load clients from the directory
      #
      client {
        #   Where to start searching in the tree for clients
        base_dn = "${..base_dn}"

        #
        #  Filter to match client objects
        #
        filter = '(objectClass=radiusClient)'

        # Search scope, may be 'base', 'one', 'sub' or 'children'
    #    scope = 'sub'

        #
        #  Sets default values (not obtained from LDAP) for new client entries
        #
        template {
    #      login        = 'test'
    #      password      = 'test'
    #      proto         = tcp
    #      require_message_authenticator  = yes

          # Uncomment to add a home_server with the same
          # attributes as the client.
    #      coa_server {
    #        response_window = 2.0
    #      }
        }

        #
        #  Client attribute mappings are in the format:
        #      <client attribute> = <ldap attribute>
        #
        #  The following attributes are required:
        #    * ipaddr | ipv4addr | ipv6addr - Client IP Address.
        #    * secret - RADIUS shared secret.
        #
        #  All other attributes usually supported in a client
        #  definition are also supported here.
        #
        #  Schemas are available in doc/schemas/ldap for openldap and eDirectory
        #
        attribute {
          ipaddr        = 'radiusClientIdentifier'
          secret        = 'radiusClientSecret'
    #      shortname      = 'radiusClientShortname'
    #      nas_type      = 'radiusClientType'
    #      virtual_server      = 'radiusClientVirtualServer'
    #      require_message_authenticator  = 'radiusClientRequireMa'
        }
      }

      #  Load clients on startup
    #  read_clients = no

      #
      #  Modify user object on receiving Accounting-Request
      #

      #  Useful for recording things like the last time the user logged
      #  in, or the Acct-Session-ID for CoA/DM.
      #
      #  LDAP modification items are in the format:
      #   <ldap attr> <op> <value>
      #
      #  Where:
      #    <ldap attr>:  The LDAP attribute to add modify or delete.
      #    <op>:     One of the assignment operators:
      #      (:=, +=, -=, ++).
      #      Note: '=' is *not* supported.
      #    <value>:  The value to add modify or delete.
      #
      #  WARNING: If using the ':=' operator with a multi-valued LDAP
      #  attribute, all instances of the attribute will be removed and
      #  replaced with a single attribute.
      accounting {
        reference = "%{tolower:type.%{Acct-Status-Type}}"

        type {
          start {
            update {
              description := "Online at %S"
            }
          }

          interim-update {
            update {
              description := "Last seen at %S"
            }
          }

          stop {
            update {
              description := "Offline at %S"
            }
          }
        }
      }

      #
      #  Post-Auth can modify LDAP objects too
      #
      post-auth {
        update {
          description := "Authenticated at %S"
        }
      }

      #
      #  LDAP connection-specific options.
      #
      #  These options set timeouts, keep-alives, etc. for the connections.
      #
      options {
        #  Control under which situations aliases are followed.
        #  May be one of 'never', 'searching', 'finding' or 'always'
        #  default: libldap's default which is usually 'never'.
        #
        #  LDAP_OPT_DEREF is set to this value.
    #    dereference = 'always'

        #
        #  The following two configuration items control whether the
        #  server follows references returned by LDAP directory.
        #  They are  mostly for Active Directory compatibility.
        #  If you set these to 'no', then searches will likely return
        #  'operations error', instead of a useful result.
        #
        chase_referrals = yes
        rebind = yes

        # SASL Security Properties (see SASL_SECPROPS in ldap.conf man page).
        # Note - uncomment when using GSS-API sasl mechanism along with TLS
        # encryption against Active-Directory LDAP servers (this disables
        # sealing and signing at the GSS level as required by AD).
        #sasl_secprops = 'noanonymous,noplain,maxssf=0'

        #  Seconds to wait for LDAP query to finish. default: 20
        res_timeout = 10

        #  Seconds LDAP server has to process the query (server-side
        #  time limit). default: 20
        #
        #  LDAP_OPT_TIMELIMIT is set to this value.
        srv_timelimit = 3

        #  Seconds to wait for response of the server. (network
        #  failures) default: 10
        #
        #  LDAP_OPT_NETWORK_TIMEOUT is set to this value.
        net_timeout = 1

        #  LDAP_OPT_X_KEEPALIVE_IDLE
        idle = 60

        #  LDAP_OPT_X_KEEPALIVE_PROBES
        probes = 3

        #  LDAP_OPT_X_KEEPALIVE_INTERVAL
        interval = 3

        #  ldap_debug: debug flag for LDAP SDK
        #  (see OpenLDAP documentation).  Set this to enable
        #  huge amounts of LDAP debugging on the screen.
        #  You should only use this if you are an LDAP expert.
        #
        #  default: 0x0000 (no debugging messages)
        #  Example:(LDAP_DEBUG_FILTER+LDAP_DEBUG_CONNS)
        ldap_debug = 0x0028
      }

      #
      #  This subsection configures the tls related items
      #  that control how FreeRADIUS connects to an LDAP
      #  server.  It contains all of the 'tls_*' configuration
      #  entries used in older versions of FreeRADIUS.  Those
      #  configuration entries can still be used, but we recommend
      #  using these.
      #
      tls {
        # Set this to 'yes' to use TLS encrypted connections
        # to the LDAP database by using the StartTLS extended
        # operation.
        #
        # The StartTLS operation is supposed to be
        # used with normal ldap connections instead of
        # using ldaps (port 636) connections
    #    start_tls = yes

    #    ca_file  = ${certdir}/cacert.pem

    #    ca_path  = ${certdir}
    #    certificate_file = /path/to/radius.crt
    #    private_key_file = /path/to/radius.key
    #    random_file = /dev/urandom

         #  Certificate Verification requirements.  Can be:
        #    'never' (do not even bother trying)
         #    'allow' (try, but don't fail if the certificate
        #    cannot be verified)
        #    'demand' (fail if the certificate does not verify)
        #    'hard'  (similar to 'demand' but fails if TLS
        #             cannot negotiate)
         #
        #  The default is libldap's default, which varies based
        #  on the contents of ldap.conf.

    #    require_cert  = 'demand'
      }

      #  As of version 3.0, the 'pool' section has replaced the
      #  following configuration items:
      #
      #  ldap_connections_number

      #  The connection pool is new for 3.0, and will be used in many
      #  modules, for all kinds of connection-related activity.
      #
      #  When the server is not threaded, the connection pool
      #  limits are ignored, and only one connection is used.
      pool {
        #  Connections to create during module instantiation.
        #  If the server cannot create specified number of
        #  connections during instantiation it will exit.
        #  Set to 0 to allow the server to start without the
        #  directory being available.
        start = ${thread[pool].start_servers}

        #  Minimum number of connections to keep open
        min = ${thread[pool].min_spare_servers}

        #  Maximum number of connections
        #
        #  If these connections are all in use and a new one
        #  is requested, the request will NOT get a connection.
        #
        #  Setting 'max' to LESS than the number of threads means
        #  that some threads may starve, and you will see errors
        #  like 'No connections available and at max connection limit'
        #
        #  Setting 'max' to MORE than the number of threads means
        #  that there are more connections than necessary.
        max = ${thread[pool].max_servers}

        #  Spare connections to be left idle
        #
        #  NOTE: Idle connections WILL be closed if "idle_timeout"
        #  is set.  This should be less than or equal to "max" above.
        spare = ${thread[pool].max_spare_servers}

        #  Number of uses before the connection is closed
        #
        #  0 means "infinite"
        uses = 0

        #  The number of seconds to wait after the server tries
        #  to open a connection, and fails.  During this time,
        #  no new connections will be opened.
        retry_delay = 30

        #  The lifetime (in seconds) of the connection
        lifetime = 0

        #  Idle timeout (in seconds).  A connection which is
        #  unused for this length of time will be closed.
        idle_timeout = 60

        #  NOTE: All configuration settings are enforced.  If a
        #  connection is closed because of 'idle_timeout',
        #  'uses', or 'lifetime', then the total number of
        #  connections MAY fall below 'min'.  When that
        #  happens, it will open a new connection.  It will
        #  also log a WARNING message.
        #
        #  The solution is to either lower the 'min' connections,
        #  or increase lifetime/idle_timeout.
      }
    }

  raddb-mods-enabled-mschap: |
    # -*- text -*-
    #
    #  $Id: 1748d5747f5b2fda08a017ad3095d9b96b0c2ee0 $

    #
    #  Microsoft CHAP authentication
    #
    #  This module supports MS-CHAP and MS-CHAPv2 authentication.
    #  It also enforces the SMB-Account-Ctrl attribute.
    #
    mschap {
            #
            #  If you are using /etc/smbpasswd, see the 'passwd'
            #  module for an example of how to use /etc/smbpasswd
            #

            #
            #  If use_mppe is not set to no mschap, will
            #  add MS-CHAP-MPPE-Keys for MS-CHAPv1 and
            #  MS-MPPE-Recv-Key/MS-MPPE-Send-Key for MS-CHAPv2
            #
    #       use_mppe = no

            #
            #  If MPPE is enabled, require_encryption makes
            #  encryption moderate
            #
    #       require_encryption = yes

            #
            #  require_strong always requires 128 bit key
            #  encryption
            #
    #       require_strong = yes

            #
            #  This module can perform authentication itself, OR
            #  use a Windows Domain Controller.  This configuration
            #  directive tells the module to call the ntlm_auth
            #  program, which will do the authentication, and return
            #  the NT-Key.  Note that you MUST have "winbindd" and
            #  "nmbd" running on the local machine for ntlm_auth
            #  to work.  See the ntlm_auth program documentation
            #  for details.
            #
            #  If ntlm_auth is configured below, then the mschap
            #  module will call ntlm_auth for every MS-CHAP
            #  authentication request.  If there is a cleartext
            #  or NT hashed password available, you can set
            #  "MS-CHAP-Use-NTLM-Auth := No" in the control items,
            #  and the mschap module will do the authentication itself,
            #  without calling ntlm_auth.
            #
            #  Be VERY careful when editing the following line!
            #
            #  You can also try setting the user name as:
            #
            #       ... --username=%{mschap:User-Name} ...
            #
            #  In that case, the mschap module will look at the User-Name
            #  attribute, and do prefix/suffix checks in order to obtain
            #  the "best" user name for the request.
            #
            #  For Samba 4, you should also set the "ntlm auth" parameter
            #  in the Samba configuration:
            #
            #       ntlm auth = yes
            #
            #  or
            #
            #       ntlm auth = mschapv2-and-ntlmv2-only
            #
            #  This will let Samba 4 accept the MS-CHAP authentication
            #  method that is needed by FreeRADIUS.
            #
            #  Depending on the Samba version, you may also need to add:
            #
            #       --allow-mschapv2
            #
            #  to the command-line parameters.
            #
    #       ntlm_auth = "/path/to/ntlm_auth --request-nt-key --allow-mschapv2 --username=%{%{Stripped-User-Name}:-%{%{User-Name}:-None}} --challenge=%{%{mschap:Challenge}:-00} --nt-response=%{%{mschap:NT-Response}:-00}"

            #
            #  The default is to wait 10 seconds for ntlm_auth to
            #  complete.  This is a long time, and if it's taking that
            #  long then you likely have other problems in your domain.
            #  The length of time can be decreased with the following
            #  option, which can save clients waiting if your ntlm_auth
            #  usually finishes quicker. Range 1 to 10 seconds.
            #
    #       ntlm_auth_timeout = 10

            #
            #  An alternative to using ntlm_auth is to connect to the
            #  winbind daemon directly for authentication. This option
            #  is likely to be faster and may be useful on busy systems,
            #  but is less well tested.
            #
            #  Using this option requires libwbclient from Samba 4.2.1
            #  or later to be installed. Make sure that ntlm_auth above is
            #  commented out.
            #
            winbind_username = "%{mschap:User-Name}"
            winbind_domain = "%{mschap:NT-Domain}"

            #
            #  When using single sign-on with a winbind connection and the
            #  client uses a different casing for the username than the
            #  casing is according to the backend, reauth may fail because
            #  of some Windows internals. This switch tries to find the
            #  user in the correct casing in the backend, and retry
            #  authentication with that username.
            #
    #       winbind_retry_with_normalised_username = no

            #
            #  Information for the winbind connection pool.  The configuration
            #  items below are the same for all modules which use the new
            #  connection pool.
            #
            pool {
                    #
                    #  Connections to create during module instantiation.
                    #  If the server cannot create specified number of
                    #  connections during instantiation it will exit.
                    #  Set to 0 to allow the server to start without the
                    #  winbind daemon being available.
                    #
                    start = ${thread[pool].start_servers}

                    #
                    #  Minimum number of connections to keep open
                    #
                    min = ${thread[pool].min_spare_servers}

                    #
                    #  Maximum number of connections
                    #
                    #  If these connections are all in use and a new one
                    #  is requested, the request will NOT get a connection.
                    #
                    #  Setting 'max' to LESS than the number of threads means
                    #  that some threads may starve, and you will see errors
                    #  like 'No connections available and at max connection limit'
                    #
                    #  Setting 'max' to MORE than the number of threads means
                    #  that there are more connections than necessary.
                    #
                    max = ${thread[pool].max_servers}

                    #
                    #  Spare connections to be left idle
                    #
                    #  NOTE: Idle connections WILL be closed if "idle_timeout"
                    #  is set.  This should be less than or equal to "max" above.
                    #
                    spare = ${thread[pool].max_spare_servers}

                    #
                    #  Number of uses before the connection is closed
                    #
                    #  0 means "infinite"
                    #
                    uses = 0

                    #
                    #  The number of seconds to wait after the server tries
                    #  to open a connection, and fails.  During this time,
                    #  no new connections will be opened.
                    #
                    retry_delay = 30

                    #
                    #  The lifetime (in seconds) of the connection
                    #
                    #  NOTE: A setting of 0 means infinite (no limit).
                    #
                    lifetime = 86400

                    #
                    #  The pool is checked for free connections every
                    #  "cleanup_interval".  If there are free connections,
                    #  then one of them is closed.
                    #
                    cleanup_interval = 300

                    #
                    #  The idle timeout (in seconds).  A connection which is
                    #  unused for this length of time will be closed.
                    #
                    #  NOTE: A setting of 0 means infinite (no timeout).
                    #
                    idle_timeout = 600

                    #
                    #  NOTE: All configuration settings are enforced.  If a
                    #  connection is closed because of "idle_timeout",
                    #  "uses", or "lifetime", then the total number of
                    #  connections MAY fall below "min".  When that
                    #  happens, it will open a new connection.  It will
                    #  also log a WARNING message.
                    #
                    #  The solution is to either lower the "min" connections,
                    #  or increase lifetime/idle_timeout.
                    #
            }

            passchange {
                    #
                    #  This support MS-CHAPv2 (not v1) password change
                    #  requests.  See doc/mschap.rst for more IMPORTANT
                    #  information.
                    #
                    #  Samba/ntlm_auth - if you are using ntlm_auth to
                    #  validate passwords, you will need to use ntlm_auth
                    #  to change passwords.  Uncomment the three lines
                    #  below, and change the path to ntlm_auth.
                    #
    #               ntlm_auth = "/usr/bin/ntlm_auth --helper-protocol=ntlm-change-password-1"
    #               ntlm_auth_username = "username: %{mschap:User-Name}"
    #               ntlm_auth_domain = "nt-domain: %{mschap:NT-Domain}"

                    #
                    #  To implement a local password change, you need to
                    #  supply a string which is then expanded, so that the
                    #  password can be placed somewhere.  e.g. passed to a
                    #  script (exec), or written to SQL (UPDATE/INSERT).
                    #  We give both examples here, but only one will be
                    #  used.
                    #
    #               local_cpw = "%{exec:/path/to/script %{mschap:User-Name} %{MS-CHAP-New-Cleartext-Password}}"
                    #
    #               local_cpw = "%{sql:UPDATE radcheck set value='%{MS-CHAP-New-NT-Password}' where username='%{SQL-User-Name}' and attribute='NT-Password'}"
            }

            #
            #  For Apple Server, when running on the same machine as
            #  Open Directory.  It has no effect on other systems.
            #
    #       use_open_directory = yes

            #
            #  On failure, set (or not) the MS-CHAP error code saying
            #  "retries allowed".
            #
    #       allow_retry = yes

            #
            #  An optional retry message.
            #
    #       retry_msg = "Re-enter (or reset) the password"
    }
  
  raddb-clients: |
    client localhost {
      ipaddr = localhost
      secret = testing123
    }
    client "client" {
      ipaddr = 0.0.0.0/0
      proto = udp
      secret = 'VAULT_REPLACE_CLIENT_SECRET_REPLACE_VAULT'
      require_message_authenticator = no
      nas_type = other
      limit {
        max_connections = 16
        lifetime = 0
        idle_timeout = 30
      }
    }